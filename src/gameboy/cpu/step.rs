use crate::gameboy::gameboy::{*};
use crate::gameboy::cpu::exec::{*};
use crate::gameboy::cpu::instruction::{*};

/// Decode the instruction at PC, then execute it and update PC and cycle count accordingly.
pub fn step(gb: &mut Gameboy) -> Result<(), String> {
    let instr = decode(gb, gb.pc)?;
    match instr {
        // Control/misc
        Instr::Nop             => (),
        Instr::Stop            => stop(gb),
        Instr::Halt            => halt(gb),
        Instr::Di              => di(gb),
        Instr::Ei              => ei(gb),
        Instr::Ccf             => ccf(gb),
        Instr::Scf             => scf(gb),
        Instr::Daa             => daa(gb),
        Instr::Cpl             => cpl(gb),
        // 8-bit load
        Instr::Ld(dst, src)    => ld(gb, dst, src),
        Instr::LdInc(dst, src) => ld_inc_dec(gb, dst, src, IncDec::Inc),
        Instr::LdDec(dst, src) => ld_inc_dec(gb, dst, src, IncDec::Dec),
        // 16-bit load
        Instr::Ld16(dst, src)  => ld_16(gb, dst, src),
        Instr::Push(r_pair)    => push(gb, r_pair),
        Instr::Pop(r_pair)     => pop(gb, r_pair),
        // 8-bit arithmetic
        Instr::Inc(dst)        => inc_dec(gb, dst, IncDec::Inc),
        Instr::Dec(dst)        => inc_dec(gb, dst, IncDec::Dec),
        Instr::Add(src)        => add_sub(gb, src, AddSub::Add, CarryMode::NoCarry),
        Instr::Adc(src)        => add_sub(gb, src, AddSub::Add, CarryMode::WithCarry),
        Instr::Sub(src)        => add_sub(gb, src, AddSub::Sub, CarryMode::NoCarry),
        Instr::Sbc(src)        => add_sub(gb, src, AddSub::Sub, CarryMode::WithCarry),
        Instr::And(src)        => bitwise(gb, src, BitwiseOp::And),
        Instr::Xor(src)        => bitwise(gb, src, BitwiseOp::Xor),
        Instr::Or(src)         => bitwise(gb, src, BitwiseOp::Or),
        Instr::Cp(src)         => cp(gb, src),
        // 16-bit arithmetic
        Instr::Add16HL(src)    => add_16_hl(gb, src),
        Instr::Add16SP(n)      => add_16_sp(gb, n),
        Instr::Inc16(dst)      => inc_dec_16(gb, dst, IncDec::Inc),
        Instr::Dec16(dst)      => inc_dec_16(gb, dst, IncDec::Dec),
        // Control-flow
        Instr::Jp(src)         => jp(gb, src),
        Instr::JpCC(cc, nn)    => jp_cond(gb, cc, nn),
        Instr::Jr(offset)      => jr(gb, offset),
        Instr::JrCC(cc, off)   => jr_cond(gb, cc, off),
        Instr::Call(nn)        => call(gb, nn),
        Instr::CallCC(cc, nn)  => call_cond(gb, cc, nn),
        Instr::Ret             => ret(gb),
        Instr::RetCC(cc)       => ret_cond(gb, cc),
        Instr::Reti            => reti(gb),
        Instr::Rst(n)          => rst(gb, n),
        // Rotates, shifts, bit operations
        Instr::Rlca            => rlca(gb),
        Instr::Rla             => rla(gb),
        Instr::Rrca            => rrca(gb),
        Instr::Rra             => rra(gb),
        Instr::Rlc(dst)        => rlc(gb, dst),
        Instr::Rrc(dst)        => rrc(gb, dst),
        Instr::Rl(dst)         => rl(gb, dst),
        Instr::Rr(dst)         => rr(gb, dst),
        Instr::Sla(dst)        => sla(gb, dst),
        Instr::Sra(dst)        => sra(gb, dst),
        Instr::Srl(dst)        => srl(gb, dst),
        Instr::Bit(bt, dst)    => bit(gb, bt, dst),
        Instr::Res(bt, dst)    => res(gb, bt, dst),
        Instr::Set(bt, dst)    => set(gb, bt, dst),
        Instr::Swap(dst)       => swap(gb, dst),
    }
    gb.pc += instr.size(gb).0;
    gb.cycles += instr.num_cycles(gb);
    Ok(())
}

pub fn decode(gb: &Gameboy, addr: u16) -> Result<Instr, String> {
    let opcode = gb.read(addr);
    // The bottom three bits of the opcode are used to indicate src reg for certain loads
    let src_reg = reg_encoding_to_src(opcode & 0b0000_0111)?;
    // Grab data from addr+1 and addr+2 in case we need them as arguments
    // This shouldn't go out of bounds since instructions aren't executed in top of mem
    let n = gb.read(addr + 1);
    let n2 = gb.read(addr + 2);
    // n and n2 intepreted as LSB 16-bit value
    let nn = ((n2 as u16) << 8) | (n as u16);
    // For 0xCB instructions, n encodes a register in the bottom three bits
    let cb_reg = reg_encoding_to_dst(n & 0b0000_0111)?;
    match opcode {
        0x00        => Ok(Instr::Nop),
        0x01        => Ok(Instr::Ld16(Dst16::R16(RBC), Src16::D16(nn))),
        0x02        => Ok(Instr::Ld(Dst8::Id(RBC), Src8::R8(RA))),
        0x03        => Ok(Instr::Inc16(Dst16::R16(RBC))),
        0x04        => Ok(Instr::Inc(Dst8::R8(RB))),
        0x05        => Ok(Instr::Dec(Dst8::R8(RB))),
        0x06        => Ok(Instr::Ld(Dst8::R8(RB), Src8::D8(n))),
        0x07        => Ok(Instr::Rlca),
        0x08        => Ok(Instr::Ld16(Dst16::IdNN(nn), Src16::RSP)),
        0x09        => Ok(Instr::Add16HL(Src16::R16(RBC))),
        0x0a        => Ok(Instr::Ld(Dst8::R8(RA), Src8::Id(RBC))),
        0x0b        => Ok(Instr::Dec16(Dst16::R16(RBC))),
        0x0c        => Ok(Instr::Inc(Dst8::R8(RC))),
        0x0d        => Ok(Instr::Dec(Dst8::R8(RC))),
        0x0e        => Ok(Instr::Ld(Dst8::R8(RC), Src8::D8(n))),
        0x0f        => Ok(Instr::Rrca),

        0x10        => Ok(Instr::Stop),
        0x11        => Ok(Instr::Ld16(Dst16::R16(RDE), Src16::D16(nn))),
        0x12        => Ok(Instr::Ld(Dst8::Id(RDE), Src8::R8(RA))),
        0x13        => Ok(Instr::Inc16(Dst16::R16(RDE))),
        0x14        => Ok(Instr::Inc(Dst8::R8(RD))),
        0x15        => Ok(Instr::Dec(Dst8::R8(RD))),
        0x16        => Ok(Instr::Ld(Dst8::R8(RD), Src8::D8(n))),
        0x17        => Ok(Instr::Rla),
        0x18        => Ok(Instr::Jr(n as i8)),
        0x19        => Ok(Instr::Add16HL(Src16::R16(RDE))),
        0x1a        => Ok(Instr::Ld(Dst8::R8(RA), Src8::Id(RDE))),
        0x1b        => Ok(Instr::Dec16(Dst16::R16(RDE))),
        0x1c        => Ok(Instr::Inc(Dst8::R8(RE))),
        0x1d        => Ok(Instr::Dec(Dst8::R8(RE))),
        0x1e        => Ok(Instr::Ld(Dst8::R8(RE), Src8::D8(n))),
        0x1f        => Ok(Instr::Rra),

        0x20        => Ok(Instr::JrCC(Cond::Nz, n as i8)),
        0x21        => Ok(Instr::Ld16(Dst16::R16(RHL), Src16::D16(nn))),
        0x22        => Ok(Instr::LdInc(Dst8::Id(RHL), Src8::R8(RA))),
        0x23        => Ok(Instr::Inc16(Dst16::R16(RHL))),
        0x24        => Ok(Instr::Inc(Dst8::R8(RH))),
        0x25        => Ok(Instr::Dec(Dst8::R8(RH))),
        0x26        => Ok(Instr::Ld(Dst8::R8(RH), Src8::D8(n))),
        0x27        => Ok(Instr::Daa),
        0x28        => Ok(Instr::JrCC(Cond::Z, n as i8)),
        0x29        => Ok(Instr::Add16HL(Src16::R16(RHL))),
        0x2a        => Ok(Instr::LdInc(Dst8::R8(RA), Src8::Id(RHL))),
        0x2b        => Ok(Instr::Inc16(Dst16::R16(RHL))),
        0x2c        => Ok(Instr::Inc(Dst8::R8(RL))),
        0x2d        => Ok(Instr::Dec(Dst8::R8(RL))),
        0x2e        => Ok(Instr::Ld(Dst8::R8(RL), Src8::D8(n))),
        0x2f        => Ok(Instr::Cpl),

        0x30        => Ok(Instr::JrCC(Cond::Nc, n as i8)),
        0x31        => Ok(Instr::Ld16(Dst16::RSP, Src16::D16(nn))),
        0x32        => Ok(Instr::LdDec(Dst8::Id(RHL), Src8::R8(RA))),
        0x33        => Ok(Instr::Inc16(Dst16::RSP)),
        0x34        => Ok(Instr::Inc(Dst8::Id(RHL))),
        0x35        => Ok(Instr::Dec(Dst8::Id(RHL))),
        0x36        => Ok(Instr::Ld(Dst8::Id(RHL), Src8::D8(n))),
        0x37        => Ok(Instr::Scf),
        0x38        => Ok(Instr::JrCC(Cond::C, n as i8)),
        0x39        => Ok(Instr::Add16HL(Src16::RSP)),
        0x3a        => Ok(Instr::LdDec(Dst8::R8(RA), Src8::Id(RHL))),
        0x3b        => Ok(Instr::Dec16(Dst16::RSP)),
        0x3c        => Ok(Instr::Inc(Dst8::R8(RA))),
        0x3d        => Ok(Instr::Dec(Dst8::R8(RA))),
        0x3e        => Ok(Instr::Ld(Dst8::R8(RA), Src8::D8(n))),
        0x3f        => Ok(Instr::Ccf),

        0x40..=0x47 => Ok(Instr::Ld(Dst8::R8(RB), src_reg)),
        0x48..=0x4f => Ok(Instr::Ld(Dst8::R8(RC), src_reg)),
        0x50..=0x57 => Ok(Instr::Ld(Dst8::R8(RD), src_reg)),
        0x58..=0x5f => Ok(Instr::Ld(Dst8::R8(RE), src_reg)),
        0x60..=0x67 => Ok(Instr::Ld(Dst8::R8(RH), src_reg)),
        0x68..=0x6f => Ok(Instr::Ld(Dst8::R8(RL), src_reg)),
        0x70..=0x75 => Ok(Instr::Ld(Dst8::Id(RHL), src_reg)),
        0x76        => Ok(Instr::Halt),
        0x77        => Ok(Instr::Ld(Dst8::Id(RHL), Src8::R8(RA))),
        0x78..=0x7f => Ok(Instr::Ld(Dst8::R8(RA), src_reg)),

        0x80..=0x87 => Ok(Instr::Add(src_reg)),
        0x88..=0x8f => Ok(Instr::Adc(src_reg)),
        0x90..=0x97 => Ok(Instr::Sub(src_reg)),
        0x98..=0x9f => Ok(Instr::Sbc(src_reg)),
        0xa0..=0xa7 => Ok(Instr::And(src_reg)),
        0xa8..=0xaf => Ok(Instr::Xor(src_reg)),
        0xb0..=0xb7 => Ok(Instr::Or(src_reg)),
        0xb8..=0xbf => Ok(Instr::Cp(src_reg)),

        0xc0        => Ok(Instr::RetCC(Cond::Nz)),
        0xc1        => Ok(Instr::Pop(RBC)),
        0xc2        => Ok(Instr::JpCC(Cond::Nz, nn)),
        0xc3        => Ok(Instr::Jp(Src16::D16(nn))),
        0xc4        => Ok(Instr::CallCC(Cond::Nz, nn)),
        0xc5        => Ok(Instr::Push(RBC)),
        0xc6        => Ok(Instr::Add(Src8::D8(n))),
        0xc7        => Ok(Instr::Rst(0x00)),
        0xc8        => Ok(Instr::RetCC(Cond::Z)),
        0xc9        => Ok(Instr::Ret),
        0xca        => Ok(Instr::JpCC(Cond::Z, nn)),
        0xcb        => match n {
            0x00..=0x07 => Ok(Instr::Rlc(cb_reg)),
            0x08..=0x0f => Ok(Instr::Rrc(cb_reg)),
            0x10..=0x17 => Ok(Instr::Rl(cb_reg)),
            0x18..=0x1f => Ok(Instr::Rr(cb_reg)),
            0x20..=0x27 => Ok(Instr::Sla(cb_reg)),
            0x28..=0x2f => Ok(Instr::Sra(cb_reg)),
            0x30..=0x37 => Ok(Instr::Swap(cb_reg)),
            0x38..=0x3f => Ok(Instr::Srl(cb_reg)),

            0x40..=0x47 => Ok(Instr::Bit(0, cb_reg)),
            0x48..=0x4f => Ok(Instr::Bit(1, cb_reg)),
            0x50..=0x57 => Ok(Instr::Bit(2, cb_reg)),
            0x58..=0x5f => Ok(Instr::Bit(3, cb_reg)),
            0x60..=0x67 => Ok(Instr::Bit(4, cb_reg)),
            0x68..=0x6f => Ok(Instr::Bit(5, cb_reg)),
            0x70..=0x77 => Ok(Instr::Bit(6, cb_reg)),
            0x78..=0x7f => Ok(Instr::Bit(7, cb_reg)),

            0x80..=0x87 => Ok(Instr::Res(0, cb_reg)),
            0x88..=0x8f => Ok(Instr::Res(1, cb_reg)),
            0x90..=0x97 => Ok(Instr::Res(2, cb_reg)),
            0x98..=0x9f => Ok(Instr::Res(3, cb_reg)),
            0xa0..=0xa7 => Ok(Instr::Res(4, cb_reg)),
            0xa8..=0xaf => Ok(Instr::Res(5, cb_reg)),
            0xb0..=0xb7 => Ok(Instr::Res(6, cb_reg)),
            0xb8..=0xbf => Ok(Instr::Res(7, cb_reg)),

            0xc0..=0xc7 => Ok(Instr::Set(0, cb_reg)),
            0xc8..=0xcf => Ok(Instr::Set(1, cb_reg)),
            0xd0..=0xd7 => Ok(Instr::Set(2, cb_reg)),
            0xd8..=0xdf => Ok(Instr::Set(3, cb_reg)),
            0xe0..=0xe7 => Ok(Instr::Set(4, cb_reg)),
            0xe8..=0xef => Ok(Instr::Set(5, cb_reg)),
            0xf0..=0xf7 => Ok(Instr::Set(6, cb_reg)),
            0xf8..=0xff => Ok(Instr::Set(7, cb_reg)),
        },
        0xcc        => Ok(Instr::CallCC(Cond::Z, nn)),
        0xcd        => Ok(Instr::Call(nn)),
        0xce        => Ok(Instr::Adc(Src8::D8(n))),
        0xcf        => Ok(Instr::Rst(0x08)),

        0xd0        => Ok(Instr::RetCC(Cond::Nc)),
        0xd1        => Ok(Instr::Pop(RDE)),
        0xd2        => Ok(Instr::JpCC(Cond::Nc, nn)),
        0xd3        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xd4        => Ok(Instr::CallCC(Cond::Nc, nn)),
        0xd5        => Ok(Instr::Push(RDE)),
        0xd6        => Ok(Instr::Sub(Src8::D8(n))),
        0xd7        => Ok(Instr::Rst(0x10)),
        0xd8        => Ok(Instr::RetCC(Cond::C)),
        0xd9        => Ok(Instr::Reti),
        0xda        => Ok(Instr::JpCC(Cond::C, nn)),
        0xdb        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xdc        => Ok(Instr::CallCC(Cond::C, nn)),
        0xdd        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xde        => Ok(Instr::Sbc(Src8::D8(n))),
        0xdf        => Ok(Instr::Rst(0x18)),

        0xe0        => Ok(Instr::Ld(Dst8::IdFF(n), Src8::R8(RA))),
        0xe1        => Ok(Instr::Pop(RHL)),
        0xe2        => Ok(Instr::Ld(Dst8::IdFFRC, Src8::R8(RA))),
        0xe3        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xe4        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xe5        => Ok(Instr::Push(RHL)),
        0xe6        => Ok(Instr::And(Src8::D8(n))),
        0xe7        => Ok(Instr::Rst(0x20)),
        0xe8        => Ok(Instr::Add16SP(n as i8)),
        0xe9        => Ok(Instr::Jp(Src16::R16(RHL))),
        0xea        => Ok(Instr::Ld(Dst8::IdNN(nn), Src8::R8(RA))),
        0xeb        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xec        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xed        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xee        => Ok(Instr::Xor(Src8::D8(n))),
        0xef        => Ok(Instr::Rst(0x28)),

        0xf0        => Ok(Instr::Ld(Dst8::R8(RA), Src8::IdFF(n))),
        0xf1        => Ok(Instr::Pop(RAF)),
        0xf2        => Ok(Instr::Ld(Dst8::R8(RA), Src8::IdFFRC)),
        0xf3        => Ok(Instr::Di),
        0xf4        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xf5        => Ok(Instr::Push(RAF)),
        0xf6        => Ok(Instr::Or(Src8::D8(n))),
        0xf7        => Ok(Instr::Rst(0x30)),
        0xf8        => Ok(Instr::Ld16(Dst16::R16(RHL), Src16::SPD8(n as i8))),
        0xf9        => Ok(Instr::Ld16(Dst16::RSP, Src16::R16(RHL))),
        0xfa        => Ok(Instr::Ld(Dst8::R8(RA), Src8::IdNN(nn))),
        0xfb        => Ok(Instr::Ei),
        0xfc        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xfd        => Err(format!("Invalid opcode {:#2x}", opcode)),
        0xfe        => Ok(Instr::Cp(Src8::D8(n))),
        0xff        => Ok(Instr::Rst(0x38)),
    }
}

fn reg_encoding_to_dst(encoding: u8) -> Result<Dst8, String> {
    match encoding {
        0 => Ok(Dst8::R8(RB)),
        1 => Ok(Dst8::R8(RC)),
        2 => Ok(Dst8::R8(RD)),
        3 => Ok(Dst8::R8(RE)),
        4 => Ok(Dst8::R8(RH)),
        5 => Ok(Dst8::R8(RL)),
        6 => Ok(Dst8::Id(RHL)),
        7 => Ok(Dst8::R8(RA)),
        _ => Err(format!("Invalid encoding: {:0>3b}", encoding)),
    }
}

// Repetitive, but okay for now I guess
fn reg_encoding_to_src(encoding: u8) -> Result<Src8, String> {
    match encoding {
        0 => Ok(Src8::R8(RB)),
        1 => Ok(Src8::R8(RC)),
        2 => Ok(Src8::R8(RD)),
        3 => Ok(Src8::R8(RE)),
        4 => Ok(Src8::R8(RH)),
        5 => Ok(Src8::R8(RL)),
        6 => Ok(Src8::Id(RHL)),
        7 => Ok(Src8::R8(RA)),
        _ => Err(format!("Invalid encoding: {:0>3b}", encoding)),
    }
}
